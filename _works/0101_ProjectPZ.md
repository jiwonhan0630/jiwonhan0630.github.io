---
layout: basic
title: "Project PZ"
description: "실시간 턴제 전략 액션"
image: /images/pic01.jpg
---

### 프로젝트 개요
- Android
- Unity Engine

## 담당 업무

### 절차적 레벨·메쉬 생성
- 절차적 레벨 생성: [Wang Tile](https://en.wikipedia.org/wiki/Wang_tile) 알고리즘을 응용하여 절차적인 지형 생성 구현
- 절차적 메쉬 생성: 생성된 레벨 데이터를 기반으로 필요한 부분의 지형 메쉬를 생성·텍스처 적용
- Unity Tilemap 시스템을 사용한 월드맵: 생성된 레벨 데이터를 Tilemap 시스템에 적용하여 인게임 월드맵 구현

### 몬스터 패턴 시스템
디자이너가 작성한 데이터에 따라 몬스터가 행동하는 패턴 시스템 구현

### 청크 시스템
플레이어의 위치를 기준으로 영역 밖의 오브젝트 및 지형을 비활성화.  
- 타임 스탬프 기반 AI 동기화: 플레이어가 청크 진입 시, 몬스터의 마지막 동작 시간과 현재 시간의 차이를 통해 몬스터의 행동을 연산 후 동기화

### 커스텀 에디터
- 레벨 디자인 툴: 절차적 생성을 위한 베이스 데이터 및 사전 정의된 레벨 작업 툴 구현
- 데이터 기반 구조물 배치: 플레이 데이터에 따라 구조물의 종류와 위치를 동적으로 변경하여 배치하는 시스템 구현

### CSV 관련 유틸리티
JSONUtility를 참고하여 CSV 데이터를 직렬하는 유틸리티 구현

### 성능 최적화
- 절차적 레벨 생성 프로세스 개선: 각종 최적화 기법을 적용하여 레벨 생성 시간을 대폭 감소
- UniTask 적용: 비동기 로직(로딩, 에셋 로드 등)에 UniTask를 적용하여 메모리 할당을 최소화


## 절차적 레벨 생성
미리 만들어진 작은 지형 데이터의 집합으로 영역을 만들고, 영역의 집합으로 하나의 레벨을 만들어내는 로직을 구현하였습니다.  
영역과 영역은 인접 가능한 지점이 정해져있고, 해당 지점을 통해서만 이동이 가능한 구조로 생성되어야 했음  
이는 절차적 텍스처 합성에 사용되는 Wang Tile을 응용하여 실현 가능하다고 판단, 생성 로직을 구상 후 문서로 작성하여 디자이너와 나의 뇌를 동기화.  

## 청크 시스템

## 맵 데이터 에디터·프리뷰 기능
결과적으로는 그림판 수준이지만 일단 기능 나열...  
- 포토샵 같은 곳에 있는 네비게이션 기능
- 브러쉬 크기 조절, 브러쉬 마스크 기능...
- 인게임 적용 예시 보기(?)
    - 지금까지의 데이터를 인게임처럼 보여준다. 인게임과 동일한 메시 생성기를 사용하므로 모듈화도 되어있다는 걸 자랑할 수 있다...  
    - 플레이어 조작도 가능...
- 에셋 프리뷰 쪽에서 시각화된 상태로 보여준다...
    - 팀원들의 빠른 보고서 작성을 위해 png로 출력해주는 기능도 있음...  
UIToolkit을 사용하여 기능과 디자인을 분리했으므로 나중에 UI 디자이너가 요소를 수정하기 편하게 했음...  

## 몬스터 패턴 디버깅 툴
몬스터가 어떤 틱에서 어떤 행동을 취했는지 목록으로 보여준다...  
디자이너가 작성한 데이터대로 굴러가는지 보는 용도였다...  

## 데이터 기반 몬스터 패턴 시스템
디자이너가 쓴 텍스트를 파싱해서 지정된 함수를 호출시키는 형태이다...  

## CSV 형식 파싱 자동화(?)
이거는 Attribute를 통해서...헤더의 이름과 동일한 변수에 값을 넣어주는 친구이다...  
List와 Dictionary 두가지 방식을 사용할 수 있고...Dictionary의 경우 키를 무슨 값으로 할건지 이름 정해줄 수 있음...  



# Troubleshooting
[Zero allocation과 propagation를 통한 성능 개선](#){: .btn-sub sub="절차적 레벨 생성 과정에서의 문제 발생과 해결"}

### 문제 발생
아니 어느 순간부터 맵 한번 만들어지는거 보려면 무슨 8분 10분을 기다려야하더라고요?  
이게 뭐 특정 컴퓨터에서만 오래걸리는게 아니라 뭐 뭘 써도 다 똑같이 오래걸림  
벌써부터 이렇게 오래걸리면 진짜 미래가 걱정되는 수준 아니겠음?...  
일단 재미검증용으로 작성된 프로토타입 코드를 리팩토링하지 않고 그대로 사용했기에 예상하고 있던 문제긴 함

### 원인 파악
Profiler를 통한 분석 결과 심각한 GC 오버헤드(GC.Alloc, GC.Collect)와 함수 자체의 긴 동작 시간으로 인한 문제임을 파악하였습니다.  
이후 ProfilerMarker를 사용하여 GC 오버헤드가 발생하는 정확한 지점과, 많은 동작 시간을 할애하는 함수를 특정하여,  
아래와 같이 원인을 정리하였습니다.

1. 불필요한 객체 생성으로 인한 GC 오버헤드
    - 좌표 클래스의 연산자 오버로딩으로 인해 매 연산마다 새로운 객체 생성
    - 다음 지형 생성 위치를 선정하기 위한 오버랩 체크 시 타일의 개수만큼 새로운 객체 생성
    - 결과물 가공 후 버려지는 데이터들의 해제 처리
2. LINQ 사용으로 인한 GC 오버헤드
    - ToList, ToDictionary등의 함수로 인한 새로운 객체 생성 및 반복적인 Resizing
    - 콜렉션의 Enumerator가 LINQ용 인터페이스로 캐스팅되는 Boxing 발생
3. Coroutine 사용으로 인한 GC 오버헤드
4. 지형 생성 위치 선정 함수의 긴 동작 시간

### 문제 해결
#### GC 오버헤드 제거·구조 재설계

LINQ 사용으로 인해 발생하는 문제를 아래와 같이 해결하였습니다.
- 콜렉션을 미리 생성함과 동시에 Capacity를 계산하여, 함수 내에서의 생성과 Resizing을 최소화하였습니다.
    - Memory Profiler를 통해 예약된 메모리와 콜렉션의 최종 크기가 동일함을 검증했습니다.
- 쿼리 함수를 for/while를 사용한 순회로 변경하여 새로운 콜렉션을 생성하지 않도록 하였습니다.

스펙에 맞지 않는 구조를 재설계하였습니다.
- 런타임 최적화에 사용하던 청크 구조를 생성 단계에 도입하여 관련 로직의 평균 연산 속도를 개선하였습니다.
- 좌표 클래스를 구조체로 변경하는 동시에 지형 정보를 담고 있던 string 등 참조 타입의 변수를 제거하여 GC.Alloc이 완전히 일어나지 않도록 하였습니다.
- 일부 지형을 정의하기 위해 사용되는 클래스의 생성을 제거하고 단순한 계산식으로 수정하였습니다.
- List 순회 대신 HashSet과 Dictionary을 사용하여 평균 데이터 접근 속도를 개선하였습니다.

또한 일부 함수는 코루틴으로 작성되었는데, 코루틴은 컴파일 단계에서 클래스로 선언되어 작동하기 때문에 GC.Alloc이 일어나게 되므로,
이를 방지하기 위해 구조체 기반의 UniTask를 도입하였습니다.

#### CPU Friendly
개선된 구조에서도 일부 함수는 최악의 경우 수십만번 이상 호출되어 실행 시간에 영향을 주는 것을 확인하였습니다.  
더 이상 호출 횟수를 줄이는 것은 어려웠기 때문에, 함수 자체의 동작 시간을 줄이기 위해 아래와 같은 방법을 통해 CPU의 처리 시간 감소를 도모하였습니다.
- 좌표 구조체의 크기를 조절하여 메모리 접근 횟수를 줄였습니다.
- 불필요한 중간 객체를 제거하고 함수 파라미터에 수식을 직접 넣어 전달하였습니다.
- 연산자 오버로딩을 제거하고 멤버의 값을 수정하는 연산 함수로 변경하였습니다.

### 결과
객체 생성 시 발생하는 필수적인 할당을 제외하면  
문제가 되는 부분에서의 Zero Allocation을 달성하였습니다.  

이후 맵 생성 속도가 얼마나 개선되었는지를 측정하기 위해  
최악의 경우를 가능한 구현(모든 청크 검사 실패, 일부 반복문 강제 순회, 기획상 최대 지형 크기 적용 등)하여 측정한 결과,  
기존 코드는 평균 380초의 동작시간, 개선한 코드는 평균 24초의 동작시간을 기록하였습니다.  
