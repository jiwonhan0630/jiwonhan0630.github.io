---
layout: basic
title: "Project PZ"
description: "실시간 턴제 전략 액션"
---

### 프로젝트 개요
- Mobile (Android)
- Unity Engine

## 담당 업무
[절차적 레벨 생성](#절차적-레벨-생성){: .button .subject .arrow sub="Wang Tile 알고리즘을 응용한 절차적 레벨 생성"}
[청크 시스템](#청크-시스템){: .button .subject .arrow sub="Spatial Hash Grid 기반의 청크 시스템"}
[CSV Utility](#csv-utility){: .button .subject .arrow sub="CSV 데이터 변환 유틸리티"}
[커스텀 에디터](#커스텀-에디터){: .button .subject .arrow sub="UIToolkit을 사용한 레벨 디자인 툴"}
[몬스터 패턴 시스템](#몬스터-패턴-시스템){: .button .subject .arrow sub="데이터 기반 몬스터 패턴"}
[Troubleshooting](#troubleshooting){: .button .subject-negative .arrow sub="절차적 레벨 생성 스크립트 리팩토링"}

# 세부 내용
## 절차적 레벨 생성
### 절차적 레벨 생성
[Wang Tile 알고리즘](https://en.wikipedia.org/wiki/Wang_tile)을 응용하여 절차적 지형을 생성하는 로직을 구현하였습니다.  
<!-- 디자이너가 설계한 다양한 크기와 형태의 작은 지형 데이터(이하 파츠)를 인접 가능한 엣지 조건에 맞춰 회전, 확장, 연결하여 지형을 생성합니다.   -->
퀘스트 진행도나 아이템 보유 여부 등 디자이너가 설정한 외부 데이터에 따라 각 파츠 Edge의 인접 조건과 오브젝트 생성 규칙이 동적으로 변경되는 구조를 설계하였습니다.  

### 절차적 메쉬 생성
[Greedy 알고리즘](https://en.wikipedia.org/wiki/Greedy_algorithm)을 통한 절차적 메쉬 생성을 구현하였습니다.  
다른 지형에 가려지거나 불필요한 정점의 생성을 가능한 방지하여 청크 단위로 나눠진 메쉬를 생성하도록 하였습니다.  
<!-- 레벨 데이터를 통해 파츠의 점유 영역을 스캔하여 최적화된 Quad 단위로 메쉬를 생성합니다. 이는 불필요한 정점 생성을 원천 차단하여 메모리 할당을 최소화합니다.   -->

### 월드맵
TilemapRenderer를 통해 생성된 지형의 모습과 오브젝트의 위치 등을 표시하는 월드맵 기능을 구현하였습니다.

## 청크 시스템
Spatial Hash Grid를 통해 월드 공간을 영역으로 나누고 활성 상태를 관리하는 청크 시스템을 구현하였습니다.  
플레이어의 이동에 따라 각 청크의 활성 상태가 전환되는 시점에 월드 타임스탬프를 기록하여,  
재활성화 시 공백 시간 동안의 오브젝트 상태 변화를 수식 기반으로 즉시 보정할 수 있는 구조를 설계하였습니다.

## 커스텀 에디터
### 레벨 디자인 툴
절차적 레벨 생성에 사용되는 파츠 데이터를 작업할 수 있는 레벨 에디터를 구현하였습니다.  
- UIToolkit을 통해 기능과 UI 요소를 분리하여 디자인 수정에 유연하게 대응할 수 있는 구조를 설계하였습니다.  
- 모듈화된 절차적 레벨 생성 기능을 호출하여 인게임과 동일한 절차로 생성되는 모습을 확인하며 작업할 수 있는 구조를 설계하였습니다.
- 파츠의 ObjectPreview 기능과 스냅샷 출력 기능을 통해 툴을 사용하지 않더라도 파츠의 모습을 확인할 수 있도록 하였습니다.  

## CSV Utility
Reflection과 Attribute를 통해, 별도의 파싱 로직 작성 없이 CSV 데이터를 변환할 수 있는 유틸리티를 구현하였습니다.
<!-- int, string 등의 기본 자료형을 넘어 Enum, List, Dictionary 등 복합 자료형으로의 변환이 가능하도록 구현하였습니다.
또한 변수명과 CSV 헤더명이 다르더라도 Attribute를 통해 이름을 수정하거나 특정 열을 지정하여 매핑할 수 있도록 설계하였습니다 -->
```csharp
[CSVFormat(typeof(Item))]
class Item()
{
    public string Code;

    // CSV 헤더명이 변수명과 다를 경우, 이름이나 인덱스로 매핑 가능
    [CSVName("Item_Tag_Code_List")]
    public List<string> TagList; // 리플렉션을 통해 enum, 컬렉션 등 다양한 타입으로의 변환 지원

    [CSVIndex(4)] 
    public int MaxLevel;
}

// List, Dictionary<key, List<>>등 다양한 컬렉션 사용 가능
Dictionary<string, Item> resultDictionary = new();

CSVUtility.TryFromText("text", nameof(Item.Code), out resultDictionary);
CSVUtility.TryToText("address", resultDictionary);
```
## 몬스터 패턴 시스템

### CSV 기반 몬스터 FSM
몬스터의 행동 패턴을 CSV 텍스트로 작성하여 FSM으로 동작시키는 시스템을 구현하였습니다.  
각 행에 부여된 속성 키에 따라 내용을 다르게 파싱하는 방식으로, 새로운 상태를 생성하거나 상태별 전이 조건, 사용 스킬 등을 정의하여 사용할 수 있도록 하였습니다.  

### 몬스터 패턴 뷰어
UIToolkit을 통해 몬스터의 패턴을 시각화하는 뷰어를 구현하였습니다.  
스테이지에 생성된 몬스터의 이전 동작이나 다음 틱에 실행할 동작을 확인할 수 있도록 하였습니다.  

# Troubleshooting
## 문제 상황
테스트 기기 환경에서 거대한 레벨을 생성할 경우, 300초 이상의 긴 시간이 소모되는 현상이 발생하였습니다.  

## 원인 분석
Profiler를 통한 분석 결과 심각한 GC 오버헤드(GC.Alloc, GC.Collect)와 함수 자체의 긴 동작 시간을 핵심 원인으로 파악하였습니다.  
이는 재미검증용으로 작성된 프로토타입 스크립트가 리팩토링 없이 적용되어 발생한 문제입니다.  
이후 ProfilerMarker를 사용하여 GC 오버헤드가 발생하는 정확한 지점과, 많은 동작 시간을 할애하는 함수를 특정하여,  
아래와 같이 원인을 정리하였습니다.

1. 불필요한 객체 생성으로 인한 GC 오버헤드
    - 좌표 클래스의 연산자 오버로딩으로 인해 매 연산마다 새로운 객체 생성
    - 다음 지형 생성 위치를 선정하기 위한 오버랩 체크 시 타일의 개수만큼 새로운 객체 생성
    - 결과물 가공 후 버려지는 데이터들의 해제 처리
2. LINQ 사용으로 인한 GC 오버헤드
    - ToList, ToDictionary등의 함수로 인한 새로운 객체 생성 및 반복적인 Resizing
    - 콜렉션의 Enumerator가 LINQ용 인터페이스로 캐스팅되는 Boxing 발생
3. Coroutine 사용으로 인한 GC 오버헤드

## 해결 과정
### GC 오버헤드 제거
좌표 클래스를 구조체로 변경하는 동시에 지형 정보를 담고 있던 string 등 참조 타입의 변수를 제거하여 GC.Alloc이 완전히 일어나지 않도록 하였습니다.  
또한 LINQ 사용으로 인해 발생하는 문제점을 해결하기 위해 아래와 같이 수정하였습니다.
- 콜렉션을 미리 생성함과 동시에 Capacity를 계산하여, 함수 내에서의 생성과 Resizing을 최소화하였습니다.
    - Memory Profiler를 통해 예약된 메모리와 콜렉션의 최종 크기가 동일함을 검증했습니다.
- 쿼리 함수를 for/while를 사용한 순회로 변경하여 새로운 콜렉션을 생성하지 않도록 하였습니다.
- List 순회 대신 HashSet과 Dictionary을 사용하여 평균 데이터 접근 속도를 개선하였습니다.

또한 일부 함수는 코루틴으로 작성되었는데, 코루틴은 컴파일 단계에서 클래스로 선언되어 작동하기 때문에 GC.Alloc이 일어나게 되므로,
이를 방지하기 위해 구조체 기반의 UniTask를 도입하였습니다.  

### 청크 시스템 적용
청크 시스템의 Spatial Hash Grid를 적용하여 좌표 단위로 실행하는 동작을 영역 단위로 실행하도록 수정하였습니다.  
오버랩 체크, 영역 회전, 확장 등 관련 함수의 호출 횟수와 평균 데이터 접근 속도를 개선하였습니다.  

### CPU Friendly
개선된 구조에서도 일부 함수는 최악의 경우 수십만번 이상 호출되어 실행 시간에 영향을 주는 것을 확인하였습니다.  
더 이상 호출 횟수를 줄이는 것은 어려웠기 때문에, 함수 자체의 동작 시간을 줄이기 위해 아래와 같은 방법을 통해 CPU의 처리 시간 감소를 도모하였습니다.
- 좌표 구조체의 크기를 조절하여 메모리 접근 횟수를 줄였습니다.
- 불필요한 중간 객체를 제거하고 함수 파라미터에 수식을 직접 넣어 전달하였습니다.
- 연산자 오버로딩을 제거하고 멤버의 값을 수정하는 연산 함수로 변경하였습니다.

## 결과
맵 생성 속도가 얼마나 개선되었는지를 측정하기 위해  
최악의 경우를 가능한 구현(모든 청크 검사 실패, 일부 반복문 강제 순회, 기획상 최대 지형 크기 적용 등)하여 측정한 결과,  
기존 로직은 평균 380초의 동작시간, 개선한 로직은 평균 14초의 동작시간을 기록하였습니다.  

또한 객체 생성 시 발생하는 필수적인 할당 등을 제외,  
문제가 되는 부분에서의 Zero Allocation을 달성하였습니다.  
